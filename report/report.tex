\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{color}
\usepackage{svg}
\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{4}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\renewcommand{\thesection}{\Roman{section}}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=cyan,
}
\lstnewenvironment{cc}
{
\lstset{frame=tblr,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}}
{}

\begin{document}
\title{
  \begin{minipage}\linewidth
      \centering
      Projet AOA sujet 10
      \vskip 5pt
      \author{
        ALEXANDRE Julien \\
        \texttt{julien.alexandre@isty.uvsq.fr}
      \and
        VIRLOGEUX Marin \\
        \texttt{marin.virlogeux@isty.uvsq.fr}
      \and
        LEDOYEN Paul \\
        \texttt{paul.ledoyen@isty.uvsq.fr}
      \and
        DRISSI Mohamed Reda \\
        \texttt{reda-mohamed@isty.uvsq.fr}
      }
    \end{minipage}
}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Introduction}
 \subsection{Objectifs}
  	L'objectif de ce projet est d'étudier un noyau de code et d'optimiser sa compilation. Nous traitons ici la phase I de ce projet qui consiste en 
  	\begin{itemize}
  	\item mesurer la performance du noyau pour différents niveaux d'optimisations de gcc et d'icc
  	\item trouver d'autres options d'optimisations pertinentes
	\item expliquer les différences de performances entre versions d'optimisation avec MAQAO ou likwid
	\item justifier l'implémentation du driver
  	\end{itemize}
  \subsection{Spécifications de la machine utilisée}
  Nous avons traité les différents cas sur la même machine pour conserver une certaine constance dans les mesures effectuées.
    \begin{itemize}
      \item CPU : \href{https://ark.intel.com/products/88195/Intel-Core-i7-6700K-Processor-8M-Cache-up-to-4_20-GHz}
        {intel core i7 6700K 4.0GHZ 4 physical cores, 8 logical(HyperThreading©) turbo boost off}
      \item RAM : Corsair CMK16GX4M2B3000C15 Vengeance LPX 16GB DDR4 3000MHz C15 XMP 2.0
      \item Stockage : \href{http://downloadcenter.samsung.com/content/UM/201711/20171115103115156/Samsung_SSD_850_PRO_Data_Sheet_Rev_3.pdf}
          {Samsung 850 PRO SSD 512GB}
    \end{itemize}
    \subsection{Système}
      \begin{itemize}
      \item OS : Debian 9.4 Stretch (stable) x86\_64
      \item Kernel :  4.9.0-6-amd64
      \item gcc : 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)
      \item icc : 18.0.1 20171018
    \end{itemize}
  \subsection{Topologie du système}
    \begin{figure}[ht!]
      \centering
      \includegraphics[scale=0.35]{resources/lstopo.png}
      \caption{Topologie générée par \href{https://manpages.debian.org/jessie/hwloc/lstopo.1.en.html}{lstopo}}
    \end{figure}
  \newpage
  \subsection{Noyau}
  Le noyau traité est le suivant :
    \lstinputlisting[language=c]{../subject10.c}
    
 
\section{Détermination des paramètres}
  \subsection{Taille des données}
    Notre boucle utilise un tableau de \texttt{double} de taille $n\times n$
    chaque case prend 8 octets. \\
    Donc le coût total (en mémoire) de notre boucle sera de $8n^2$ . \\

    Si nous voulons utiliser L1, L2, L3 ou la ram il faut trouver l'intervalle de chacun
    Soit T la taille maximale (qui serait en puissance de 2 alors $T=2^t$) :
    \begin{align}
      8n^2 \leq 2^t \\
      n \leq 2^{\frac{t-3}{2}}
    \end{align}
    Les données des différents caches et ram sont
    \begin{itemize}
      \item L1 : 32Ko   = $2^{15}$ octets
      \item L2 : 256Ko  = $2^{18}$ octets
      \item L3 : 8192Ko = $2^{23}$ octets
      \item RAM: 16Gb   = $2^{34}$ octets
    \end{itemize}
    \vspace{5mm}
    \begin{tabular}{|l| c | c | c|}
      \hline
      Mémoire & $2^t$ & Taille & coût \\\hline
      \hline
      L1 & 15 & 64 & 31.64Ko \\\hline
      L2 & 18 & 181 & 256Ko \\\hline
      L3 & 23 & 1024 & 8190Ko \\\hline
      RAM & 34 & 46340 & 16Gb \\\hline
    \end{tabular}
    
   Par précaution, nous n'allons pas prendre des tailles de tableau exactement identiques aux tailles maximales des caches, pour éviter tout débordement.
    \subsection{Nombre de warmup}
    Nous allons étudier pour chaque taille de tableau, et pour chaque option d'optimisations le nombre de cycles nécessaires (ordonnée) pour chaque itération de warmup (abscisse). On pourra ainsi déterminer approximativement le nombre de warmup necessaires pour atteindre le régime permanent.
    \subsubsection{L1 : taille 60}
      \newpage
      \paragraph{compilateur \texttt{GCC}}
        \subparagraph{ \texttt{Optimisation O2}}
      Nous trouvons ce résultat pour L1 :
      \begin{figure}[ht!]
        \centering
        \includegraphics[scale=0.45]{resources/L1/warmup/O2.png}
        \caption{Résultat du warmup avec option \texttt{O2} du compilateur \textbf{GCC}}
      \end{figure}
      
      Le pic observé correspond à une interférence, nous n'en tiendrons donc pas compte. On observe que le régime permanent est atteint très vite, on appliquera donc 20 warmups.
      \newpage
      \subparagraph{ \texttt{Optimisation O3}}
    Nous trouvons ce résultat pour L1 :
    \begin{figure}[ht!]
      \centering
      \includegraphics[scale=0.45]{resources/L1/warmup/O3.png}
      \caption{Résultat du warmup avec option \texttt{O3} du compilateur \textbf{GCC}}
    \end{figure}
    
    Ici on observe un régime transitoire de très faible durée, un nombre de warmups de 20 est également suffisant.
    \newpage
\subparagraph{ \texttt{Optimisation O3 march=native}}
  Nous trouvons ce résultat pour L1 :
  \begin{figure}[ht!]
    \centering
\includegraphics[scale=0.45]{resources/L1/warmup/O3Nat.png}
    \caption{Résultat du warmup avec option \texttt{O3 march=native} du compilateur \textbf{GCC}}
  \end{figure}
  
  Le résultat obtenu ici est totalement instable, on ne peut pas identifier de stabilisation, donc opérer des warmups ne semble pas avoir de grand intérêt.
  \newpage
\subparagraph{ \texttt{Optimisation Ofast}}
Nous trouvons ce résultat pour L1 :
\begin{figure}[ht!]
  \centering
\includegraphics[scale=0.45]{resources/L1/warmup/Ofast.png}
  \caption{Résultat du warmup avec option \texttt{Ofast} du compilateur \textbf{GCC}}
\end{figure}

On observe, comme pour O3, un très court régime transitoire (inférieur à 5 cycles). Un premier warmup de 20 itérations est retenu.

\newpage
\paragraph{Compilateur \texttt{ICC©}}
    \subparagraph{ \texttt{Optimisation O2}}
  Nous trouvons ce résultat pour L1 :
  \begin{figure}[ht!]
    \centering
\includegraphics[scale=0.45]{resources/L1/warmup/O2_i.png}
    \caption{Résultat du warmup avec option \texttt{O2} du compilateur \textbf{ICC}}
    
	Très court régime transitoire, on conserve le nombre de 20 warmups.    
  \end{figure}
  \newpage
\subparagraph{ \texttt{Optimisation O3}}
Nous trouvons ce résultat pour L1 :
\begin{figure}[ht!]
  \centering
  \includegraphics[scale=0.45]{resources/L1/warmup/O3_i.png}
  \caption{Résultat du warmup avec option \texttt{O3} du compilateur \textbf{ICC}}
\end{figure}

Très court régime transitoire, on conserve le nombre de 20 warmups. 
\newpage
\subparagraph{ \texttt{Optimisation O3 xHost}}
Nous trouvons ce résultat pour L1 :
  \begin{figure}[ht!]
    \centering
    \includegraphics[scale=0.45]{resources/L1/warmup/O3Nat_i.png}
    \caption{Résultat du warmup avec option \texttt{O3 xHost} du compilateur \textbf{ICC}}
  \end{figure}
   
  Très court régime transitoire, on conserve le nombre de 20 warmups. 
  \newpage
\subparagraph{ \texttt{Optimisation Ofast}}
Nous trouvons ce résultat pour L1 :
  \begin{figure}[ht!]
    \centering
    \includegraphics[scale=0.45]{resources/L1/warmup/Ofast_i.png}
    \caption{Résultat du warmup avec option \texttt{Ofast} du compilateur \textbf{ICC}}
  \end{figure}
  
	Ici, le résultat est différent des cas prédédents : on observe que pendant les 20 premiers warmups on est en régime transitoire et qu'on se stabilise au delà. On prendra donc également 20 warmups.
	
	Rétrospectivement, étant donné le nombre très faible de warmups nécessaires à chaque configuration d'optimisation (3 ou 20 ne change pas grand chose, on reste dans le même ordre de grandeur), et par souci de simplicité, nous avons arbitrairement fixé à 20 le nombre de warmups pour toutes les options, au regard de celle étudiée dernièrement et en nécessitant plus que les autres.
  
    \subsubsection{L2 : taille 170, L3 : taille 1000, RAM : taille 20000}
    Les résultats obtenus sont très similaires, on considèrera donc pour chaque optimisation, indépendamment de la taille des données traitées par le noyau, que 20 warmups sont nécessaires à la première méta-répétition, puis on abaissera à 3 warmups pour les méta-répétions suivantes, car la machine est "chaude".
    
\section{Résultats et interprétations}
    \subsection{Compilateur GCC}
      \subsubsection{ \texttt{ Option O2 } }
     
      \subsubsection{ \texttt{ Option O3 }  }
      \subsubsection{ \texttt{ Option O3Nat} }
      \subsubsection{ \texttt{ Option Ofast } }
	      \paragraph{Justification}
	      
	      \paragraph{Optimisation \texttt{funroll-loops}}
      
      \subsection{Compilateur ICC}
      \subsubsection{ \texttt{ Option O2 } }
      \subsubsection{ \texttt{ Option O3 }  }
      \subsubsection{ \texttt{ Option O3Nat} }
      \subsubsection{ \texttt{ Option Ofast } }
      
 
\end{document}
